--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -82,6 +82,8 @@
 #include "datagram.h"
 #include "sock_destructor.h"

+#include <net/ra_nat.h>
+
 struct kmem_cache *skbuff_head_cache __ro_after_init;
 static struct kmem_cache *skbuff_fclone_cache __ro_after_init;
 #ifdef CONFIG_SKB_EXTENSIONS

@@ -1665,7 +1673,15 @@
 	memcpy((struct skb_shared_info *)(data + size),
 	       skb_shinfo(skb),
 	       offsetof(struct skb_shared_info, frags[skb_shinfo(skb)->nr_frags]));
-
+	memcpy(data, skb->head, FOE_INFO_LEN);

 	/*
 	 * if shinfo is shared we must drop the old head gracefully, but if it
 	 * is not we can just drop the old head and let the existing refcount

--- a/drivers/net/ppp/ppp_generic.c
+++ b/drivers/net/ppp/ppp_generic.c
@@ -53,6 +53,8 @@
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>

+#include <net/netfilter/nf_flow_table.h>
+
 #define PPP_VERSION	"2.4.2"

 /*
@@ -1597,6 +1599,26 @@ static int ppp_fill_forward_path(struct
 	return chan->ops->fill_forward_path(ctx, path, chan);
 }

+static int ppp_flow_offload_check(flow_offload_hw_path_t *path)
+{
+	struct ppp *ppp = netdev_priv(path->dev);
+	struct ppp_channel *chan;
+	struct channel *pch;
+
+	if (ppp->flags & SC_MULTILINK)
+		return -EOPNOTSUPP;
+
+	if (list_empty(&ppp->channels))
+		return -ENODEV;
+
+	pch = list_first_entry(&ppp->channels, struct channel, clist);
+	chan = pch->chan;
+	if (!chan->ops->flow_offload_check)
+		return -EOPNOTSUPP;
+
+	return chan->ops->flow_offload_check(chan, path);
+}
+
 static const struct net_device_ops ppp_netdev_ops = {
 	.ndo_init	 = ppp_dev_init,
 	.ndo_uninit      = ppp_dev_uninit,
@@ -1604,6 +1626,7 @@ static const struct net_device_ops ppp_n
 	.ndo_siocdevprivate = ppp_net_siocdevprivate,
 	.ndo_get_stats64 = ppp_get_stats64,
 	.ndo_fill_forward_path = ppp_fill_forward_path,
+	.ndo_flow_offload_check = ppp_flow_offload_check,
 };

 static struct device_type ppp_type = {
--- a/drivers/net/ppp/pppoe.c
+++ b/drivers/net/ppp/pppoe.c
@@ -73,6 +73,8 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>

+#include <net/netfilter/nf_flow_table.h>
+
 #include <linux/nsproxy.h>
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
@@ -995,9 +997,30 @@ static int pppoe_fill_forward_path(struc
 	return 0;
 }

+static int pppoe_flow_offload_check(struct ppp_channel *chan,
+		flow_offload_hw_path_t *path)
+{
+	struct sock *sk = (struct sock *)chan->private;
+	struct pppox_sock *po = pppox_sk(sk);
+	struct net_device *dev = po->pppoe_dev;
+
+	if (sock_flag(sk, SOCK_DEAD) ||
+			!(sk->sk_state & PPPOX_CONNECTED) || !dev)
+		return -ENODEV;
+
+	path->flags |= FLOW_OFFLOAD_PATH_PPPOE;
+	path->dev = dev;
+
+	if (path->dev->netdev_ops->ndo_flow_offload_check)
+		return path->dev->netdev_ops->ndo_flow_offload_check(path);
+
+	return 0;
+}
+
 static const struct ppp_channel_ops pppoe_chan_ops = {
 	.start_xmit = pppoe_xmit,
 	.fill_forward_path = pppoe_fill_forward_path,
+	.flow_offload_check = pppoe_flow_offload_check,
 };

 static int pppoe_recvmsg(struct socket *sock, struct msghdr *m,
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1034,6 +1034,25 @@ struct dev_ifalias {
 struct devlink;
 struct tlsdev_ops;

+#define NATFLOW_OFFLOAD_HWNAT_FAKE
+struct flow_offload_fake;
+struct flow_offload_tuple_fake;
+struct flow_offload_hw_path_fake;
+enum flow_offload_type_fake {
+	FLOW_OFFLOAD_ADD        = 0,
+	FLOW_OFFLOAD_DEL,
+};
+
+typedef struct flow_offload_fake flow_offload_t;
+typedef struct flow_offload_tuple_fake flow_offload_tuple_t;
+typedef struct flow_offload_hw_path_fake flow_offload_hw_path_t;
+typedef enum flow_offload_type_fake flow_offload_type_t;
+
+extern int (*flow_offload_add_extdev)(flow_offload_type_t type,
+		flow_offload_t *flow,
+		flow_offload_hw_path_t *src,
+		flow_offload_hw_path_t *dest);
+
 struct netdev_name_node {
 	struct hlist_node hlist;
 	struct list_head list;
@@ -1560,6 +1579,11 @@ struct net_device_ops {
 	int			(*ndo_bridge_dellink)(struct net_device *dev,
 						      struct nlmsghdr *nlh,
 						      u16 flags);
+	int			(*ndo_flow_offload_check)(flow_offload_hw_path_t *path);
+	int			(*ndo_flow_offload)(flow_offload_type_t type,
+						    flow_offload_t *flow,
+						    flow_offload_hw_path_t *src,
+						    flow_offload_hw_path_t *dest);
 	int			(*ndo_change_carrier)(struct net_device *dev,
 						      bool new_carrier);
 	int			(*ndo_get_phys_port_id)(struct net_device *dev,
--- a/include/linux/ppp_channel.h
+++ b/include/linux/ppp_channel.h
@@ -31,6 +31,7 @@ struct ppp_channel_ops {
 	int	(*fill_forward_path)(struct net_device_path_ctx *,
 				     struct net_device_path *,
 				     const struct ppp_channel *);
+	int	(*flow_offload_check)(struct ppp_channel *, flow_offload_hw_path_t *);
 };

 struct ppp_channel {
--- a/include/net/netfilter/nf_flow_table.h
+++ b/include/net/netfilter/nf_flow_table.h
@@ -176,6 +176,60 @@ struct flow_offload {
 	struct rcu_head				rcu_head;
 };

+#define FLOW_OFFLOAD_PATH_ETHERNET      BIT(0)
+#define FLOW_OFFLOAD_PATH_VLAN          BIT(1)
+#define FLOW_OFFLOAD_PATH_PPPOE         BIT(2)
+#define FLOW_OFFLOAD_PATH_STOP          BIT(3)
+#define FLOW_OFFLOAD_PATH_EXTDEV        BIT(4)
+#define FLOW_OFFLOAD_PATH_WED_DIS       BIT(5)
+#define FLOW_OFFLOAD_PATH_BRIDGE        BIT(6)
+#define FLOW_OFFLOAD_PATH_DEL           BIT(7)
+#define FLOW_OFFLOAD_PATH_TNL           BIT(8)
+
+struct flow_offload_tuple_fake {
+	union {
+		struct in_addr          src_v4;
+		struct in6_addr         src_v6;
+	};
+	union {
+		struct in_addr          dst_v4;
+		struct in6_addr         dst_v6;
+	};
+	struct {
+		__be16                  src_port;
+		__be16                  dst_port;
+	};
+
+	u8                              l3proto;
+	u8                              l4proto;
+};
+
+struct flow_offload_tuple_rhash_fake {
+	struct flow_offload_tuple_fake	tuple;
+};
+
+struct flow_offload_fake {
+	struct flow_offload_tuple_rhash_fake    tuplehash[FLOW_OFFLOAD_DIR_MAX];
+	u32                                     flags;
+	u32                                     timeout;
+	union {
+		/* Your private driver data here. */
+		void *priv;
+	};
+};
+
+struct flow_offload_hw_path_fake {
+	struct net_device *dev;
+	u32 flags;
+
+	u8 eth_src[ETH_ALEN];
+	u8 eth_dest[ETH_ALEN];
+	u16 vlan_proto;
+	u16 vlan_id;
+	u16 pppoe_sid;
+	u16 dsa_port;
+};
+
 #define NF_FLOW_TIMEOUT (30 * HZ)
 #define nf_flowtable_time_stamp	(u32)jiffies 

--- a/net/8021q/vlan_dev.c
+++ b/net/8021q/vlan_dev.c
@@ -26,6 +26,7 @@
 #include <linux/ethtool.h>
 #include <linux/phy.h>
 #include <net/arp.h>
+#include <net/netfilter/nf_flow_table.h>

 #include "vlan.h"
 #include "vlanproc.h"
@@ -809,6 +810,23 @@ static int vlan_dev_fill_forward_path(st
 	return 0;
 }

+static int vlan_dev_flow_offload_check(flow_offload_hw_path_t *path)
+{
+        struct net_device *dev = path->dev;
+        struct vlan_dev_priv *vlan = vlan_dev_priv(dev);
+
+        if (path->flags & FLOW_OFFLOAD_PATH_VLAN)
+                return -EEXIST;
+
+        path->flags |= FLOW_OFFLOAD_PATH_VLAN;
+        path->dev = vlan->real_dev;
+
+        if (vlan->real_dev->netdev_ops->ndo_flow_offload_check)
+                return vlan->real_dev->netdev_ops->ndo_flow_offload_check(path);
+
+        return 0;
+}
+
 static const struct ethtool_ops vlan_ethtool_ops = {
 	.get_link_ksettings	= vlan_ethtool_get_link_ksettings,
 	.get_drvinfo	        = vlan_ethtool_get_drvinfo,
@@ -848,6 +866,7 @@ static const struct net_device_ops vlan_
 	.ndo_fix_features	= vlan_dev_fix_features,
 	.ndo_get_iflink		= vlan_dev_get_iflink,
 	.ndo_fill_forward_path	= vlan_dev_fill_forward_path,
+	.ndo_flow_offload_check = vlan_dev_flow_offload_check,
 };

 static void vlan_dev_free(struct net_device *dev)
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -14,6 +14,7 @@
 #include <linux/ethtool.h>
 #include <linux/list.h>
 #include <linux/netfilter_bridge.h>
+#include <net/netfilter/nf_flow_table.h>

 #include <linux/uaccess.h>
 #include "br_private.h"
@@ -437,6 +438,26 @@ static int br_fill_forward_path(struct n
 	return 0;
 }

+static int br_flow_offload_check(flow_offload_hw_path_t *path)
+{
+	struct net_device *dev = path->dev;
+	struct net_bridge *br = netdev_priv(dev);
+	struct net_bridge_fdb_entry *dst;
+
+	if (!(path->flags & FLOW_OFFLOAD_PATH_ETHERNET))
+		return -EINVAL;
+
+	dst = br_fdb_find_rcu(br, path->eth_dest, path->vlan_id);
+	if (!dst || !dst->dst)
+		return -ENOENT;
+
+	path->dev = dst->dst->dev;
+	if (path->dev->netdev_ops->ndo_flow_offload_check)
+		return path->dev->netdev_ops->ndo_flow_offload_check(path);
+
+	return 0;
+}
+
 static const struct ethtool_ops br_ethtool_ops = {
 	.get_drvinfo		 = br_getinfo,
 	.get_link		 = ethtool_op_get_link,
@@ -472,6 +493,7 @@ static const struct net_device_ops br_ne
 	.ndo_bridge_dellink	 = br_dellink,
 	.ndo_features_check	 = passthru_features_check,
 	.ndo_fill_forward_path	 = br_fill_forward_path,
+	.ndo_flow_offload_check  = br_flow_offload_check,
 };

 static struct device_type br_type = {
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -172,6 +172,12 @@ static int call_netdevice_notifiers_exta
 					   struct netlink_ext_ack *extack);
 static struct napi_struct *napi_by_id(unsigned int napi_id);
 
+int (*flow_offload_add_extdev)(flow_offload_type_t type,
+		flow_offload_t *flow,
+		flow_offload_hw_path_t *src,
+		flow_offload_hw_path_t *dest) = NULL;
+EXPORT_SYMBOL(flow_offload_add_extdev);
+
 /*
  * The @dev_base_head list is protected by @dev_base_lock and the rtnl
  * semaphore.